// channel 通道
// 这节讲协程间的通信

package main

//可以这样理解下面这个例子
//发送到channel的数据（比喻成包裹）暂时的被放在这个管道中	（或者说货架），等到有人来取时移出管道

//A子协程向通道src发送0-9数字
//B子协程计算输入数字的平方
//主协程输出最后的平方数

func CalSquare() {
	//生产-消费模型
	src := make(chan int)
	dest := make(chan int, 3) //有缓冲的队列。
	//dest用有缓冲是因为消费者的消费速度比较慢（比打印更加复杂），比不上生产的速度。
	//（用异步通信不需同时在线，和同步通信需要双方同时在线的例子来理解）
	//因此，src到dest必须保持读写同步，但是dest到主协程只要保证送过去了就行，不需要管他货物有没有被拿走
	//这样不会影响速度，而且可以发现通过三个channel的传递按顺序输出的。这样可以解决生产和消费均衡的执行速度问题。
	go func() {
		//“defer”语句调用一个函数，该函数的执行被延迟到周围的函数返回的那一刻，
		//可能是因为周围的函数执行了return语句，到达了它的函数体的末尾，
		//可能是因为对应的协程出现了panic。
		defer close(src) //函数完成后及时关闭这个通道。写在最前面是因为防止下面出现return语句，怕到不了函数结束运行不了close
		for i := 0; i < 10; i++ {
			src <- i //发送到管道
		}
	}() //这个括号里的参数是要传给线程的实参，那个j int就是对应接收的形参
	go func() {
		defer close(dest)
		for i := range src { //这个子协程从src管道中取出src的数据
			dest <- i * i
		}
	}() //这个括号里的参数是要传给线程的实参，那个j int就是对应接收的形参
	for i := range dest { //主协程从dest管道中取出dest的数据
		//复杂操作
		println(i)
	}
}

func main() {
	CalSquare()
	//其它语言写一般是串行调用，go直接用并发节省时间

	//可以看到输出顺序是对的，也就是并发安全的
	//然而使用通过共享内存来通信可能会出现同一时间争夺资源的情况。导致出现幻读等情况

}
